<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- 
mapper接口代理实现编写规则:
	1. 映射文件中namespace要等于接口的全路径名称
	2. 映射文件中sql语句id要等于接口的方法名称
	3. 映射文件中传入参数类型要等于接口方法的传入参数类型
	4. 映射文件中返回结果集类型要等于接口方法的返回值类型
 -->
<mapper namespace="cn.itheima.mapper.UserMapper">

	<!--
	封装sql条件，封装以后可以重用
	id:是这个sql条件的唯一标识符
	-->
	<sql id="user_Where">
		/*
			where标签体的作用:
			会自动向sql语句中条件where关键字，
			会去掉第一个条件的and关键字
		*/
		<where>
			<if test="username != null and username !=''">
				and username like '%${username}%'
			</if>

			<if test="sex != null and sex != ''">
				and sex=#{sex}
			</if>
		</where>

	</sql>

	<!--
	id:sql语句唯一标识
	parameType:指定传入参数类型
	resultType:返回结果集类型
	#{}占位符:起到占位作用,
	如果传入的是基本类型(string,long,double,int,boolean,float等),那么#{}中的变量名称可以随意写.
	-->
	<select id="findUserById" parameterType="int" resultType="cn.itheima.pojo.User">
		select * from user where id =#{id}
	</select>

	<!--
	如果返回结果为集合，可以调用selectList方法，这个方法返回的结果就是一个集合，所以映射文件中应该
	配置成集合泛型的类型
	${}拼接符:字符串原样拼接，如果传入的参数是基本类型(String,long,double,int ,boolean,float等),
	那么${}中的变量名称必须是value
	注意:拼接符有sql注入的风险，所以谨慎使用
	-->
	<select id="findUserByUserName" parameterType="string" resultType="user">
		select * from user where username like '%${value}%'
	</select>

	<!--
	执行select LAST_INSERT_ID() 数据库函数，返回自增的主键
	keyProperty:价格返回的主键放入传入参数的id中保存
	order:当前函数相对与insert语句的执行顺序，在insert之前执行的是before，在insert后执行的AFTER
	resultType:id的类型，也就是keyproperty中属性的类型
	-->
	<insert id="insertUser" parameterType="cn.itheima.pojo.User">
	<selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
		select LAST_INSERT_ID()
	</selectKey>
	insert into user (username,birthday,sex,address) values(#{username}, #{birthday},#{sex}, #{address})
	</insert>

	<select id="findUserByVo" parameterType="cn.itheima.pojo.QueryVo"
			resultType="cn.itheima.pojo.User">
		select * from user where username like '%{user.username}%' and sex=#{user.sex}
	</select>

	<!--只有返回结果为一行一列的时候，那么返回值类型才可以是基本类型-->
	<select id="findUserCount" resultType="java.lang.Integer">
		select count(*) from user
	</select>

	<select id="findUserByUserNameAndSex" parameterType="cn.itheima.pojo.User"
			resultType="cn.itheima.pojo.User">
		select * from user

		/*调用sql条件*/
		<include refid="user_Where"></include>
	</select>

	<select id="findUserByIds" parameterType="cn.itheima.pojo.QueryVo"
			resultType="cn.itheima.pojo.User">
		select * from user
		<where>
			<if test="ids != null">
				/*
				foreach:循环传入的集合参数
				colloection:传入的集合的变量名称
				item:每次循环将循环出的数据放入这个变量中
				open:循环开始拼接的字符串
				close:循环结束拼接的字符串
				separator:循环中拼接的分隔符
				*/
				<foreach collection="ids" item="id" open="id in (" close=")" separator=",">
					#{id}
				</foreach>
			</if>
		</where>
	</select>

	<!--一对一:自动映射(这种使用更加简单)-->
	<select id="findOrdersAndUser1" resultType="cn.itheima.pojo.CustomOrders">
		select a.*,b.id uid, username, birthday, sex, address
		from orders a, user b
		where a.user_id = b.id
	</select>

	<!--一对一:手动映射-->
	<!--
	id:resultMap的唯一标识
	type:将查询出的数据放入这个指定的对象中
	注意:手动映射需要指定数据库中表的字段名和java中pojo类的属性名称的对应关系
	-->

	<resultMap type="cn.itheima.pojo.Orders" id="orderAndUserResultMap">
		<!--
		id标签指定主键字符按对应关系
		column:列，数据库中的字段名称
		property:属性，java中pojo中的属性名称
		-->
		<id column="id" property="id"/>

		<!--result:标签指定非主键字段的对应的关系-->
		<result column="user_id" property="userId"></result>
		<result column="number" property="number"></result>
		<result column="createtimer" property="createtimer"></result>
		<result column="note" property="note"></result>

		<!--
		这个标签指定单个对向的对应关系
		property:指定将数据放入orders中的user属性中
		javaType:user属性的类型
		-->
		<association property="user" javaType="cn.itheima.pojo.User">
			<id column="uid" property="id"/>
			<result column="username" property="username"/>
			<result column="birthday" property="birthday"/>
			<result column="sex" property="sex"/>
			<result column="address" property="address"/>
		</association>
	</resultMap>

	<select id="findOrdersAndUser2" resultMap="orderAndUserResultMap">
		select a.*, b.id uid, username, birthday, sex, address
		from orders a, user b
		where a.user_id = b.id
	</select>

	<resultMap type="cn.itheima.pojo.User" id="userAndOrdersResultMap">
		<id column="id" property="id"/>
		<id column="username" property="username"/>
		<result column="birthday" property="birthday"/>
		<result column="sex" property="sex"/>
		<result column="address" property="address"/>

		<!--
		指定对应的集合对象关系映射
		property:将数据放入User对象中的orderList属性中
		ofType:指定orderList属性的泛型类型
		-->
		<collection property="ordersList" ofType="cn.itheima.pojo.Orders">
			<id column="id" property="id"/>
			<id column="user_id" property="userId"/>
			<id column="number" property="number"/>
			<id column="createtimer" property="createtimer"/>
		</collection>
	</resultMap>
	<select id="findUserAndOrders" resultMap="userAndOrdersResultMap">
		select a.*, b.id oid ,user_id, number, createtime
		from user a, orders b where a.id = b.user_id
	</select>

</mapper>





























